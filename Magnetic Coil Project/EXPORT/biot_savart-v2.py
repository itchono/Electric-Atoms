import numpy as np
import time

'''
BIOT-SAVART Calculator v2
Accelerated using numpy meshgrids

You will need to provide:
- A series of points in (x, y, z) describing the geometry of a coil, used as our magnet. [coil.txt]
- A rectangular box of a certain size, with a certain offset position
- An amount of current going into the coil

- Resolution at which you want to conduct your measurements

Please see configuration section.

Mingde Yin
May 29, 2020
'''

'''
CONFIGURATION OF VARIABLES
'''
CURRENT = 1 # Ampere
#AV: This spec should be moved to the coil file, so that we can do calculations for coils that have non uniform current patterns.

BOX_SIZE = (30, 15, 16) # dimensions of box in cm (x, y, z)
BOX_OFFSET = (-5, -2.5, -7.5) # where the bottom left corner of the box is w/r to the coil coordinate system.

COIL_RESOLUTION = 1 # cm; affects runtime of calculation process linearly, and increases precision up to a point
VOLUME_RESOLUTION = 1 # cm; affects runtime of calculation process in n^3, and size of resulting targetVolume


def parseCoil(filename):
    with open(filename, "r") as f:
        lines = [eval(l) for l in f.read().splitlines()] # tuples
        return np.array(lines).T

COIL = parseCoil("coil.txt")
# cartesian points in cm
'''
FILE FORMAT
Tuples Stored in form:
(x1, y1, z1)
(x2, y2, z2)
.
.
.
(xn, yn, zn)
'''
#AV: Store as (xn,yn,zn,In) ?
#AV: store coil spec as columns in text file, rather than tuples? (Tuples don't mean anything outside Python anyway.) That way, the coil file could be generated by some kind of CAD/sketching utility if needed.


def sliceCoil(coil, steplength):
    '''
    Slices a coil into smaller steplength-sized pieces based on the coil resolution
    '''
    
    def getEquidistantPoints(p1, p2, parts):
        '''
        Produces a series of linearly spaced points between two given points in R3
        '''
        return np.column_stack((np.linspace(p1[0], p2[0], parts+1),
                np.linspace(p1[1], p2[1], parts+1),
                np.linspace(p1[2], p2[2], parts+1)))

    newcoil = np.zeros((1, 3)) # fill with dummy column

    segment_starts = coil[:,:-1]
    segment_ends = coil[:,1:]
    # determine start and end of each segment

    segments = segment_ends-segment_starts
    segment_lengths = np.apply_along_axis(np.linalg.norm, 0, segments)
    # create segments; determine start and end of each segment, as well as segment lengths

    # chop up into smaller bits (elements)
    stepnumbers = (segment_lengths/steplength).astype(int)
    # determine how many steps we must chop each segment into

    for i in range(segments.shape[1]):
        # still slow; TODO how to turn into numpy?
        newrows = getEquidistantPoints(segment_starts[:,i], segment_ends[:,i], stepnumbers[i])
        # set of new interpolated points to feed in
        newcoil = np.vstack((newcoil, newrows))

    return newcoil[1:,:].T # return non-dummy columns

def calculateField(coil, current, x, y, z):
    '''
    Calculates magnetic field vector as a result of some position x, y, z
    [In the same coordinate system as the coil]

    Coil: Input Coil Positions, already sub-divided into small pieces using sliceCoil
    
    #AV: Output B-field is a vector in units of G
    '''

    FACTOR = 10**(-7) # equals mu_0 / 4pi in SI units: T m/A
    #AV: note mu_0/4pi = 1e-7 in SI units, which means the current needs to be in A, and lengths in m (not cm !) to get an output in T
    #AV: I suggest changing FACTOR to 0.1, which will return the B-field in G when the current is in A and all lengths are in cm.

    B = 0

    for i in range(coil.shape[1]-1):
        start = coil[:,i]
        end = coil[:,i+1]
        # determine start and end points of our line segment

        dl = end - start
        dl = dl.T
        midstep = (start + end)/2 
        # this is the effective position of our element (r' in the paper)
        # midpoint approximation for numerical integration

        difference = np.array([x-midstep[0], y-midstep[1], z-midstep[2]]).T

        mag = np.sqrt((x-midstep[0])**2 + (y-midstep[1])**2 + (z-midstep[2])**2)

        db = current * np.cross(dl, difference) * FACTOR / np.array((mag ** 3, mag ** 3, mag ** 3)).T
        # Biot-Savart Law
        # Needs the whole transpose thing because "operands could not be broadcast together with shapes (31,16,17,3) (17,16,31) "
        # quirk with meshgrids

        B += db
    
    return B # return SUM of all components
    # evaluated using produceTargetVolume
    #AV: Confirm that B is a vector (of meshgrids)
    

def produceTargetVolume(coil, current, startpoint, steplength):
    '''
    Generates a set of field vector values for each tuple (x, y, z) in the box.

    Coil: Input Coil Positions in format specified above, already sub-divided into small pieces
    Current: Amount of current in amps flowing through coil from [start of coil] to [end of coil]
    Startpoint: (x, y, z) = (0, 0, 0) position of the box (30 x 15 x 15) cm
    Steplength: Spatial resolution (in cm)
    '''
    x = np.arange(startpoint[0], startpoint[0] + BOX_SIZE[0] + steplength, steplength)
    y = np.arange(startpoint[1], startpoint[1] + BOX_SIZE[1] + steplength, steplength)
    z = np.arange(startpoint[2], startpoint[2] + BOX_SIZE[2] + steplength, steplength)
    # Generate points at regular spacing, incl. end points
    
    Z, Y, X = np.meshgrid(z, y, x, indexing='ij')
    # NOTE: Requires axes to be flipped in order for meshgrid to work as intended
    # it's just a weird thing with numpy

    return calculateField(coil, current, X,Y,Z)

def getFieldVector(targetVolume, position):
    '''
    Returns the B vector [Bx, By, Bz] components in a generated targetVolume at a given position tuple (x, y, z) in a coordinate system
    '''
    #AV: now I see what you mean by "targetVolume" ... not the same as "coil" ! The use of the word "targetVolume" for the volume where you want the field can mislead others too.
    #AV: I recommend calling it "target volume" instead.

    relativePosition = ((np.array(position) - np.array(BOX_OFFSET)) / VOLUME_RESOLUTION).astype(int)
    # adjust to the meshgrid's system
    
    # print("Access indices: {}".format(relativePosition)) # --> if you need to debug the mesh grid

    if (relativePosition < 0).any(): return ("ERROR: Out of bounds! (negative indices)")

    try: return targetVolume[relativePosition[0], relativePosition[1], relativePosition[2], :]
    except: return ("ERROR: Out of bounds!")
    # basic error checking to see if you actually got a correct input/output


if __name__ == "__main__":
    print("Generating targetVolume...")
    t_start = time.perf_counter()
    chopped = sliceCoil(COIL, COIL_RESOLUTION)  
    targetVolume = produceTargetVolume(chopped, CURRENT, BOX_OFFSET, VOLUME_RESOLUTION)
    t_end = time.perf_counter()

    print("Target Volume made in {:.4f}s, of shape {}".format(t_end-t_start, targetVolume.shape))
    print("Starting position: {} cm with stepsize of {} cm".format(BOX_OFFSET, VOLUME_RESOLUTION))
    
    try:
        while True:
            print("Please input the position at which you want to see the B vector...")
        
            position = (eval(input("x?\n")), eval(input("y?\n")), eval(input("z?\n")))
            
            print(getFieldVector(targetVolume, position), "Gs at {} cm".format(position))
    except KeyboardInterrupt:
        print("DONE")

'''
EXTERNAL USAGE

Import all functions in this file

- The coil will load in automatically from the file "coil.txt"
- You must then slice the coil
- You must then produce a targetVolume using the coil
- Then, you can either use tgetFieldVector(), or index on your own
- NOTE: The targetVolume is stored in form [Z, Y, X, b-component] (coordinates are reversed)
'''
    
#AV: after making the above edits, please write a sample program that takes a coil specified in coil.txt and write out the B-field in the target volume into 3 separate text files (Bx.txt, By.txt, Bz.txt). 

    


